% --------------------------------------------------------------
% This is all preamble stuff that you don't have to worry about.
% Head down to where it says "Start here"
% --------------------------------------------------------------

\documentclass[12pt]{article}

\usepackage[margin=1in]{geometry}
\usepackage{amsmath,amsthm,amssymb}
\usepackage{graphicx} %This allows to include eps figures

% This is to include code
\usepackage{listings}
\usepackage{xcolor}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstdefinestyle{Python}{
    language        = Python,
    basicstyle      = \ttfamily,
    keywordstyle    = \color{blue},
    keywordstyle    = [2] \color{teal}, % just to check that it works
    stringstyle     = \color{green},
    commentstyle    = \color{red}\ttfamily
}

\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}

\newenvironment{theorem}[2][Theorem]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{lemma}[2][Lemma]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{exercise}[2][Exercise]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{reflection}[2][Reflection]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{proposition}[2][Proposition]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{corollary}[2][Corollary]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}

\begin{document}

% --------------------------------------------------------------
%                         Start here
% --------------------------------------------------------------

%\renewcommand{\qedsymbol}{\filledbox}

\title{Homework 2}%replace X with the appropriate number
\author{Thiago Henrique Pincinato\\ %replace with your name
Introduction to Signal and Image Processing
}

\maketitle

\section{Linear Filtering}
Linear Filtering is a linear operation, in which a kernel is used to determine how the neighborhood pixel will influence the new value of the center pixel. Such a technique can be used to difference proposes as, for instance, removal of pepper and salts noise (e.g box filter) or enhance of edge (e.g Sobel) 
\subsection{}
The function boxfilter(n) can be summarized as $np.ones((n, n)) / (n x n)$.

In the development phase, the condition $boxfilter(n).sum() == 1$ was used to assure that the sum of the filter was equal to 1.

\subsection{}

The function $myconv2$ was implement by using the np functions $np.shape$ (to acquire the weight and height of filter and image), $np.pad$ (to apply padding in the image), $np.flit$ (to flip the filter), $np.sum$ and $np.multiply$ (both to realize the convolution itself).

The result of such a function is a full convolution (output of size (m + k  −-  1) × (n + l −- 1)).

\subsection{}
A boxfilter of size 11  was created and this filter was used in a given image (cat.jpg). The result of such a convolution  can be seen in the figure  \ref{fig:boxfilter}.

As expected the filter blurred the image. This happens because the box filter is an average filter that, in our case, computes the average of the 120 neighboring pixels.

\begin{figure}[h]
 \centering
 \includegraphics[scale = 0.35]{boxfilter.png}
 \caption{$Original$  $and$  $filtered$  $image$}
 \label{fig:boxfilter}
\end{figure}

\subsection{}

In order to write a function that returns a 1D Gaussian filter, the functions $np.linspace$ (creation of the array x), $np.exp$ and $np.power$ (computation of the Gaussian equation itself) were used.

Furthermore, the argument filter$_-$length is incremented of 1 if, and only if, is value is a even number.  

As result, the function $gauss1d$ has no for loop, which improve efficiency and compactness.

 
\subsection{}

The function $gauss2d$ was implemented based on the functions $gauss1d$ and $myconv2$ . Firstly, the function $gauss1d$ is called, returning a 1D Gaussian array. After that, the 1D Gaussian array is copied and transposed.  Finally, the function $myconv2$ is called with the 1D Gaussian array and 1D Gaussian array transposed, returning the final 2D Gaussian filter.

The resulting 2D Gaussian filter is illustrated in the figure  \ref{fig:2dgaussianfilter}.

\begin{figure}[h]
 \centering
 \includegraphics[scale = 0.35]{2dgaussianfilter.png}
 \caption{$2D$ $Gaussian$ $filter$ }
 \label{fig:2dgaussianfilter}
\end{figure}

\subsection{}

The previous filter (exercise 1.5) was used in the image $cat.jpg$ and the result is shown in the figure \ref{fig:gaussianfilter}.

\begin{figure}[h]
 \centering
 \includegraphics[scale = 0.8]{gaussianfilter.png}
 \caption{$Gaussian$ $filter$ }
 \label{fig:gaussianfilter}
\end{figure}

Different form the boxfilter, the Gaussian filter use different weight for the neighborhood, closer pixels are more weighted than farther ones. In addition, the value of sigma plays an important role in the Gaussian distribution. Lower values of sigma tend to preserve more the image, given that the neighborhood is low weighted, and thus, the central pixel is even more relevant. Higher sigma values, however, tend to blur more the image, due to the similar distribution of weight in the neighboring pixels. When sigma goes to infinity, we have a boxfilter. 


Gaussian filters are frequently used because they can represent better the effect of optical lens when compared with boxfilters.

\subsection{}


One could apply the convolution of the image with the 1D Gaussian filter and after a another convolution with the result of the first convolution and the transpose of the 1D Gaussian filter. The result would  be exactly the same as applying the convolution with 2D Gaussian filter.

The mathematical demonstration that the result would be the same can be seen below:

\[
    I*2DG = F -> 2DG = 1DG*(1DG') -> (I*1DG)*1DG = F
\]

Where $I$ is the image, $2DG$ is 2D Gaussian filter, $1DG$ is 1D Gaussian filter, $1DG'$ is the transpose of the 1D Gaussian filter and $F$ is the filtered image.


Note that this operation is possible due to the fact that 2D Gaussian filter are symmetric and separable.

When doing the filtering process with 1D Gaussian filter and its transpose, we are realizing $m + m$ multiplication by pixel, instead of $mxm$ (2D Gaussian filter). It means that we avoid $((m x m) -(m+m))*n x n$ multiplications, where m is the filter site and n is the image size.

Therefore, we can enhance our efficiency and velocity.

\subsection{}

To show the concept developed in the previous exercise, a plot of filter size vs. computation time was done . This plot \ref{fig:ComputationTime} elucidates the size-time relation when using 2D box filter of increasing size (3,100) and the method described in subsection 1.7.

\begin{figure}[h]
 \centering
 \includegraphics[scale = 0.35]{ComputationTime.png}
 \caption{$Computation$ $Time$ }
 \label{fig:ComputationTime}
\end{figure}

As we can see, the 1D filtering approach is more efficient than 2D approach. 

At the beginning we can notice that the 2D approach is faster, which may happens due to function calls and how my code was implemented. Nevertheless, as the size of the filter increases, it is evident how much the 1D approach is better.

\section{Finding edges}
\subsection{}
\subsection{}
\subsection{}
\subsection{}
\subsection{}


\section{Corner detection}
\subsection{}
\subsection{}
\subsection{}
\subsection{}
\subsection{}

\end{document}